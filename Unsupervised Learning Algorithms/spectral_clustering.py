# -*- coding: utf-8 -*-
"""Spectral  Clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xCik9w1Or4E5pfaa0bnATQIYt5mFJDmS
"""

import numpy as np
import scipy.sparse.linalg
import matplotlib.pyplot as plt
import pandas as pd

# Need to place K cluster centers at random locations
def random_cluster_centers(X, K):
  number_of_rows = X.shape[0]
  number_of_columns = X.shape[1]
  cluster_centers = np.zeros((K, number_of_columns))
  for i in range(K):
    cluster_centers[i] = X[np.random.randint(0, number_of_rows), :]
  return cluster_centers

# Need to assign data points to the closest cluster center
def assignment(X, cluster_centers):
  K = cluster_centers.shape[0]
  Z = np.zeros((X.shape[0], 1))
  temp = np.zeros((cluster_centers.shape[0], 1))
  for i in range(X.shape[0]):
    for j in range(K):
      dist = X[i,:] - cluster_centers[j,:]
      length = np.sum(dist**2)
      temp[j] = length
    Z[i] = np.argmin(temp)+1
  return Z

# Mean of each cluster
def cluster_mean(X, Z, K):
  no_of_rows = X.shape[0]
  no_of_columns = X.shape[1]
  cluster_centers = np.zeros((K, no_of_columns))
  count = np.zeros((K,1))

  for i in range(no_of_rows):
    index = int((Z[i]-1)[0])
    cluster_centers[index,:]+=X[i,:]
    count[index]+=1
  
  return cluster_centers/count

# Error Function
def error_function(X, Z, cluster_centers):
  no_of_rows = X.shape[0]
  no_of_columns = X.shape[1]
  errors = []

  for i in range(no_of_rows):
    cluster_center = cluster_centers[int((Z[i]-1)[0])]
    error = np.linalg.norm(X[i, :] - cluster_center)
    errors.append(error**2)
  
  return sum(errors)

# K Means algorithm
def kmeans(X, K, max_iter = 100, tol = pow(10,-6) ):
    iteration = -1
    all_sse = []
    assignments = []
    
    centroids = random_cluster_centers(X, K)

    while (len(all_sse)<=1 or (iteration < max_iter and np.absolute(all_sse[iteration] - all_sse[iteration-1])/all_sse[iteration-1] >= tol)):
        iteration += 1
        assignments = assignment(X, centroids)
        centroids = cluster_mean(X, assignments, K)
        sse_kmeans = error_function(X, assignments, centroids)
        all_sse.append(sse_kmeans)        
        
     
    return (assignments, centroids, all_sse, iteration)


# Dataset
df=pd.read_csv('Dataset.csv', sep=',',header=None)
X = df.values
X = np.transpose(X)

# Calculation of the Kernel Matrix using Polynomial Kernel
def polynomial_kernel(x_i, x_j, d):
  return (1 + np.dot(x_i, x_j))**d

degree = 4
K = np.zeros((1000, 1000))
for i in range(1000):
  for j in range(1000):
    K[i][j] = polynomial_kernel(X[:, i], X[:, j], degree)
#print(np.shape(K))


# Calculation of the Kernel Matrix using RBF Kernel
def radial_basis_kernel(x_i, x_j, sigma):
  return np.exp(-((np.linalg.norm(x_i-x_j))**2)/(2*(sigma**2)))

sigma = 1
K = np.zeros((1000, 1000))
for i in range(1000):
  for j in range(1000):
    K[i][j] = radial_basis_kernel(X[:, i], X[:, j], sigma)
#print(np.shape(K))

# Eigen decomposition of K
vals, vec = scipy.sparse.linalg.eigsh(K,k=4,which='LM')
#print(vals)
#print(np.shape(vec))
vec = vec/np.linalg.norm(vec, ord=2, axis=1, keepdims=True)
#print(np.linalg.norm(vec[0]))
#print(np.linalg.norm(vec[1]))


result = kmeans(vec,K=4)
X = np.transpose(X)
x = X[:, 0]
y = X[:, 1]
assignments = result[0]
plt.scatter(x, y, c=assignments)
plt.title('Spectral Clustering with RBF Kernel(sigma=1)')

plt.title("Error function w.r.t iterations(sigma=1)")
plt.plot(result[2])
plt.show()