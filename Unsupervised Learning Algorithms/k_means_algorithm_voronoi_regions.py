# -*- coding: utf-8 -*-
"""K Means Algorithm : Voronoi Regions.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tRD0dTxze2lCTZIb0F91GTzo-5gyz3F4
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from scipy.spatial import Voronoi, voronoi_plot_2d

df=pd.read_csv('Dataset.csv', sep=',',header=None)

# X is a numpy array containing the 1000 datapoints
X = df.values
print(np.shape(X))

# Plotting the 2-D datapoints
fig = go.Figure(data=[go.Scatter(x = X[:, 0], y = X[:,1], mode='markers', marker=dict(size=8, opacity=0.5), name='data')])
fig.update_layout(xaxis_title="x", yaxis_title="y", yaxis =dict(scaleanchor = "x", scaleratio = 1))
fig.show()

# Need to place K cluster centers at random locations
def random_cluster_centers(X, K):
  number_of_rows = X.shape[0]
  number_of_columns = X.shape[1]
  cluster_centers = np.zeros((K, number_of_columns))
  for i in range(K):
    cluster_centers[i] = X[np.random.randint(0, number_of_rows), :]
  return cluster_centers

# Need to assign data points to the closest cluster center
def assignment(X, cluster_centers):
  K = cluster_centers.shape[0]
  Z = np.zeros((X.shape[0], 1))
  temp = np.zeros((cluster_centers.shape[0], 1))
  for i in range(X.shape[0]):
    for j in range(K):
      dist = X[i,:] - cluster_centers[j,:]
      length = np.sum(dist**2)
      temp[j] = length
    Z[i] = np.argmin(temp)+1
  return Z

# Mean of each cluster
def cluster_mean(X, Z, K):
  no_of_rows = X.shape[0]
  no_of_columns = X.shape[1]
  cluster_centers = np.zeros((K, no_of_columns))
  count = np.zeros((K,1))

  for i in range(no_of_rows):
    index = int((Z[i]-1)[0])
    cluster_centers[index,:]+=X[i,:]
    count[index]+=1
  
  return cluster_centers/count

def error_function(X, Z, cluster_centers):
  no_of_rows = X.shape[0]
  no_of_columns = X.shape[1]
  errors = []

  for i in range(no_of_rows):
    cluster_center = cluster_centers[int((Z[i]-1)[0])]
    error = np.linalg.norm(X[i, :] - cluster_center)
    errors.append(error**2)
  
  return sum(errors)

def kmeans(X, K, max_iter = 100, tol = pow(10,-6) ):
    iteration = -1
    all_sse = []
    assignments = []
    
    centroids = random_cluster_centers(X, K)

    while (len(all_sse)<=1 or (iteration < max_iter and np.absolute(all_sse[iteration] - all_sse[iteration-1])/all_sse[iteration-1] >= tol)):
        iteration += 1
        assignments = assignment(X, centroids)
        centroids = cluster_mean(X, assignments, K)
        sse_kmeans = error_function(X, assignments, centroids)
        all_sse.append(sse_kmeans)        
        
     
    return (assignments, centroids, all_sse, iteration)

result = kmeans(X,K=3)

centroids_x = result[1][:, 0]
centroids_y = result[1][:, 1]
x = X[:, 0]
y = X[:, 1]
assignments = result[0]
plt.scatter(x, y, c=assignments)
plt.plot(centroids_x,centroids_y, c='white', marker='.', linewidth='0.01', markerfacecolor='red', markersize=22)
plt.title("K-means Visualization (K=3)")

points = result[1]
print(points)
vor = Voronoi(points)
fig = voronoi_plot_2d(vor)
plt.title("Voronoi regions associated to each cluster center (K=3)")
plt.show()